
## 题目地址

[https://leetcode-cn.com/problems/subsets/](https://leetcode-cn.com/problems/subsets/)


给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

**说明 :**

解集不能包含重复的子集。

**示例:**
    
输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]

## 前置知识

- [Combination](https://baike.baidu.com/item/%E7%BB%84%E5%90%88/12004197)
- DFS
- Backtracking

## 思路

由于题目中给出的条件是**不含重复元素**的数组，那我们就可以单纯的把这个看作是寻找所有组合的一个问题。
那我们就需要一个方法 C(nums, size) 来帮助我们确定我们的组合 ==> 我们所需要做的就是不断扩大我们的size ==> 从0增加到nums数组的长度。


## 解法

- 重复执行我们的 combination 方法 n + 1 次(0 到 n)
- 关于combination方法
  - 1）我们需要有一个数组来记录我们目前收集到的元素 - arr
  - 2) 因为我们创建combination是从左向右开始收集的，并且一个元素只能用一次，所以我们需要有一个记录当前所在位置的一个值 - start
  - 3) 当然还有我们的size --> 这个很重要，因为size会是我们递归函数的终止条件
- 关于递归函数的实现
  - 1) 首先我们要确定我们的终止条件是：当当前收集到的元素的数量与size一致时，我们需要将这个收集到的数组储存到ans数组里 --> 当前收集到的所有元素就是指定size的一个组合
  - 2) 如果不能出发终止条件：我们需要做的就是从当前位置开始一直遍历到给定的nums数组长度-1（数组的最大下标），先将当前位置的元素储存到arr中，然后递归调用combination方法
      注意这里的size是保持不变的，但是start将要加1，因为我们需要从当前所在位置的下一个位置开始找新的元素。并且传入arr
      调用过该方法后我们需要将arr里存的元素拿出来来清除本次循环所收集到的元素

这种思路的时间复杂度：$O(n2^n)$

```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function(nums) {
    var ans = []

    for(var i = 0; i <= nums.length; i++) {
        dfs(i, 0, [])
    }
    return ans
    
    function dfs(size, start, arr) {
        if(arr.length === size) {
            ans.push(JSON.parse(JSON.stringify(arr)))
            return 
        }

        for(var i = start; i < nums.length; i++) {
            arr.push(nums[i])
            dfs(size, i + 1, arr)
            arr.pop()
        }
    }
};

```

更多题解可以访问我的LeetCode题解仓库：https://github.com/azl397985856/leetcode  。 目前已经30K star啦。

大家也可以关注我的公众号《力扣加加sa》获取更多更新鲜的LeetCode题解

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gfcuzagjalj30p00dwabs.jpg)
